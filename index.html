<!DOCTYPE html>
<html>
<head>
  <title>Audio Recording</title>
  <style>
    body {
      text-align: center;
      background-color: #c8c8c8;
    }

    h1{
      margin-top: 20vh;
    }

    #timer{
      font-size: 2rem;
    }

    #volumeMeter {
      display: inline-block;
      display: none;
      width: 30px;
      height: 500px;
      background-color: #ccc;
    }

    #volumeLevel {
      width: 100%;
      height: 100%;
      background-color: #0f0;

    }

    #recordingsList{
      width: 500px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>Audio Recording</h1>
  <button id="startButton">Start Recording</button>
  <button id="stopButton" style="display: none;">Stop Recording</button>
  <svg id="volumeMeter">
    <rect id="volumeLevel"></rect>
  </svg>
  <br/>
  <canvas width="500px" heigh="200" id="liveWave"></canvas>
  <div id="timer">00:00:00</div>
  <div id="recordingsList">
  </div>

  <script>
    // Request access to the user's microphone
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {

        let mediaRecorder;
        let chunks = [];
        let audioContext;
        let source;
        let analyser;
        
        const volumeMeter = document.getElementById('volumeMeter');
        const volumeLevel = document.getElementById('volumeLevel');

        let gen_waveforms = [];

        const canvas = document.getElementById('liveWave');
        const canvasCtx = canvas.getContext('2d');
        let fileCount = 0;
        
        let startTime;
        
        let timerInterval;
        const svgWidth = 500;
        const svgHeight = 100;

        volumeLevel.style.height = 1 + '%';

        function storeAverageAmplitude(average, milliseconds) {
          const key = Math.floor(milliseconds / 35); 
          if (gen_waveforms[key]) {
            gen_waveforms[key].avg = (gen_waveforms[key].avg * gen_waveforms[key].count + average) / (gen_waveforms[key].count + 1);
            gen_waveforms[key].count++;
          } else {
            gen_waveforms[key] = { avg: average, count: 1 };
          }
        }

        function startRecording() {
          document.getElementById('stopButton').style.display = 'inline-block';
          document.getElementById('startButton').style.display = 'none';
          gen_waveforms = [];

          chunks = [];
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = function(event) {
            chunks.push(event.data);
          };
          mediaRecorder.onstop = function() {
            const platformResolution = ['iPad Simulator','iPhone Simulator','iPod Simulator','iPad','iPhone','iPod'].includes(navigator.platform) || navigator.userAgent.toLowerCase().indexOf('safari') != -1;

            const blob = new Blob(chunks, { type: platformResolution ? 'audio/mp3'  : 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            audio.controls = true;
            audio.style.width = '500px';


            const waveformsCount = gen_waveforms.length;


            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgWidth); // Adjust the width as per your requirement
            svg.setAttribute("height", svgHeight); // Adjust the height as per your requirement
            svg.style.marginBottom = "25px";
            let x = 0;
            const incrementSize = svgWidth / waveformsCount;
            const incrementSizeFixed = incrementSize.toFixed(2);

            for (let waveform of gen_waveforms) {
              const y = 0; // Adjust the y-coordinate scaling as per your requirement

              const rectHeight = waveform.avg * (svgHeight/90); 

              let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              rect.setAttribute("x", x.toFixed(2));
              rect.setAttribute("y", ((svgHeight/2) - rectHeight / 2).toFixed(2) + 'px');
              rect.setAttribute("width", incrementSizeFixed + 'px');
              rect.setAttribute("height", rectHeight.toFixed(2) + 'px');
              rect.setAttribute("fill", "rgb("+(rectHeight*4)+","+(rectHeight*2.5-40)+","+(rectHeight*2.5-40)+")");

              svg.appendChild(rect);
              x += incrementSize;
            }
            // Append the canvas and audio elements to the recordingsList div
            const container = document.createElement('div');
            container.style.background = "#d0d0d0";
            container.style.textAlign = "left";
            container.style.borderRadius = '8px';
            container.style.marginTop = '18px';

            // container.style.display = 'inline-block';
            fileCount++;
            const h2 = document.createElement('h2');
            h2.textContent = fileCount;
            h2.style.paddingLeft = "15px";
            h2.style.paddingTop = "15px";
            container.appendChild(h2);
            container.appendChild(svg);
            container.appendChild(audio);
            document.getElementById('recordingsList').prepend(container);
          };
          mediaRecorder.start();

          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          source.connect(analyser);

          startTime = Date.now();
          timerInterval = setInterval(updateTimer, 100);
          requestAnimationFrame(updateVolumeMeter);
          requestAnimationFrame(updateLiveWave);
        }

        function stopRecording() {
          mediaRecorder.stop();
          source.disconnect();
          analyser.disconnect();
          audioContext.close();
          clearInterval(timerInterval);

          document.getElementById('stopButton').style.display = 'none';
          document.getElementById('startButton').style.display = 'inline-block';
        }

        function updateVolumeMeter() {
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);
          const average = getAverageVolume(dataArray);
          volumeLevel.style.height = average + '%';
          storeAverageAmplitude(average,  Date.now() - startTime); 
          requestAnimationFrame(updateVolumeMeter);
        }

        function updateLiveWave() {
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);

          canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

          function draw() {
            requestAnimationFrame(draw);
            analyser.getByteTimeDomainData(dataArray);
            canvasCtx.fillStyle = 'rgb(200, 200, 200)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 0, 0)';

            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
              const v = dataArray[i] / 128.0;
              const y = v * canvas.height / 2;

              if (i === 0) {
                canvasCtx.moveTo(x, y);
              } else {
                canvasCtx.lineTo(x, y);
              }

              x += sliceWidth;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
          }

          draw();
        };

        function getAverageVolume(array) {
          let values = 0;
          const length = array.length;
          for (let i = 0; i < length; i++) {
            values += array[i];
          }
          return values / length;
        }

        function updateTimer() {
          const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsedTime / 60);
          const seconds = elapsedTime % 60;
          const milliseconds = Math.floor((Date.now() - startTime)/10 % 100);
          document.getElementById('timer').textContent = padNumber(minutes) + ':' + padNumber(seconds) + ':' + padNumber(milliseconds);
        }

        function padNumber(number) {
          return number.toString().padStart(2, '0');
        }

        document.getElementById('startButton').addEventListener('click', startRecording);
        document.getElementById('stopButton').addEventListener('click', stopRecording);

      })
      .catch(function(error) {
        console.error('Error accessing microphone:', error);
      });
  </script>
</body>
</html>
