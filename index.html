<!DOCTYPE html>
<html>
<head>
  <title>Audio Recording</title>
  <style>
    body {
      text-align: center;
      background-color: #c8c8c8;
    }

    h1{
      margin-top: 20vh;
    }

    #timer{
      font-size: 2rem;
    }

    #volumeMeter {
      display: inline-block;
      position: relative; 
      /*display: none;*/
      border-radius: 4px;
      width: 15px;
      height: 150px;
      background-color: #ccc;
    }

    #volumeLevel {
      margin-top: auto;
      width: 100%;
position: absolute; 

      border-radius: 4px;
                    bottom: 0; 
      background-color: #000;

    }

    #recordingsList{
      width: 500px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>Audio Recording</h1>
  <button id="startButton">Start Recording</button>
  <button id="stopButton" style="display: none;">Stop Recording</button>
  <br>
  <div id="volumeMeter">
    <div id="volumeLevel" height="150px"></div>
  </div>
  <canvas width="485px" heigh="200" id="liveWave"></canvas>
  <div id="timer">00:00:00</div><div id="pitch">-</div>
  <div id="recordingsList">
  </div>

  <script>
    // Request access to the user's microphone
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {
        let state = 'setup';
        let mediaRecorder;
        let chunks = [];
        let audioContext;
        let source;
        let analyser;
        let localMaxima = new Array(10);
        
        const volumeMeter = document.getElementById('volumeMeter');
        const volumeLevel = document.getElementById('volumeLevel');
        const pitch = document.getElementById('pitch');


        let gen_waveforms = [];

        const canvas = document.getElementById('liveWave');
        const canvasCtx = canvas.getContext('2d');
        let fileCount = 0;
        
        let startTime;
        
        let timerInterval;
        let animationLevel;
        let animationLiveWave;
        const svgWidth = 500;
        const svgHeight = 100;

        volumeLevel.style.height = 1 + '%';

        function storeAverageAmplitude(average, milliseconds) {
          const key = Math.floor(milliseconds / 35); 
          if (gen_waveforms[key]) {
            gen_waveforms[key].avg = (gen_waveforms[key].avg * gen_waveforms[key].count + average) / (gen_waveforms[key].count + 1);
            gen_waveforms[key].count++;
          } else {
            gen_waveforms[key] = { avg: average, count: 1 };
          }
        }

        function startRecording() {
          state = 'recording';
          document.getElementById('stopButton').style.display = 'inline-block';
          document.getElementById('startButton').style.display = 'none';
          gen_waveforms = [];

          chunks = [];
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = function(event) {
            chunks.push(event.data);
          };
          mediaRecorder.onstop = function() {
            const platformResolution = ['iPad Simulator','iPhone Simulator','iPod Simulator','iPad','iPhone','iPod'].includes(navigator.platform) || navigator.userAgent.toLowerCase().indexOf('safari') != -1;

            const blob = new Blob(chunks, { type: platformResolution ? 'audio/mp3'  : 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            audio.controls = true;
            audio.style.width = '500px';


            const waveformsCount = gen_waveforms.length;


            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgWidth); // Adjust the width as per your requirement
            svg.setAttribute("height", svgHeight); // Adjust the height as per your requirement
            svg.style.marginBottom = "25px";
            let x = 0;
            const incrementSize = svgWidth / waveformsCount;
            const incrementSizeFixed = incrementSize.toFixed(2);

            for (let waveform of gen_waveforms) {
              if(waveform === undefined){
                continue;
              }
              const y = 0; // Adjust the y-coordinate scaling as per your requirement

              const rectHeight = waveform.avg * (svgHeight/90); 

              const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              rect.setAttribute("x", x.toFixed(2));
              rect.setAttribute("y", ((svgHeight/2) - rectHeight / 2).toFixed(2) + 'px');
              rect.setAttribute("width", incrementSizeFixed + 'px');
              rect.setAttribute("height", rectHeight.toFixed(2) + 'px');
              rect.setAttribute("fill", "rgb("+(rectHeight*4)+","+(rectHeight*2.5-40)+","+(rectHeight*2.5-40)+")");

              svg.appendChild(rect);
              x += incrementSize;
            }
            // Append the canvas and audio elements to the recordingsList div
            const container = document.createElement('div');
            container.style.background = "#d0d0d0";
            container.style.textAlign = "left";
            container.style.borderRadius = '8px';
            container.style.marginTop = '18px';

            // container.style.display = 'inline-block';
            fileCount++;
            const h2 = document.createElement('h2');
            h2.textContent = fileCount;
            h2.style.paddingLeft = "15px";
            h2.style.paddingTop = "15px";
            container.appendChild(h2);
            container.appendChild(svg);
            container.appendChild(audio);
            document.getElementById('recordingsList').prepend(container);
          };
          mediaRecorder.start();

          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          source.connect(analyser);

          startTime = Date.now();
          timerInterval = setInterval(updateTimer, 100);
          requestAnimationFrame(updateMainFrequency);
          requestAnimationFrame(updateVolumeMeter);
          requestAnimationFrame(updateLiveWave);
        }

        function stopRecording() {
          state = 'stoped';
          mediaRecorder.stop();
          source.disconnect();
          analyser.disconnect();
          audioContext.close();
          clearInterval(timerInterval);
          cancelAnimationFrame(animationLevel);
          cancelAnimationFrame(animationLiveWave);
          console.log(123);

          document.getElementById('stopButton').style.display = 'none';
          document.getElementById('startButton').style.display = 'inline-block';
        }



        function updateMainFrequency() {
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);

          const sampleRate = audioContext.sampleRate;
          const minFrequency = sampleRate  / 1024 / 2;
          const maxFrequency = sampleRate / 2 - minFrequency;
          const theMaxKey = maxKey(dataArray) + 1;
          const theMaxKeyOffset = maxKeyOffset(dataArray, theMaxKey);
          console.log(theMaxKeyOffset, theMaxKey);
          const theMaxKeyWithOffset = theMaxKey + theMaxKeyOffset;
          pitch.textContent = (theMaxKeyWithOffset  / 1025 * maxFrequency  - minFrequency + theMaxKeyOffset).toFixed(2) + '„éê';
          /// looks acurate, ony thing missing is 

          // this can be done by taking nnog the max value 

          // mut the max 4 values and calcuate a fraction.
          // console.log(sampleRate, minFrequency, maxFrequency, theMaxKey,  pitch.textContent);

          // storeAverageAmplitude(average,  Date.now() - startTime); 
          if(state === 'recording'){requestAnimationFrame(updateMainFrequency)};
        }


        function maxKey(array) {

          let max = -10000;
          let maxKey = 0;
          for (var i = 0; i < array.length; i++) {
            if(array[i] < max){
              continue;
            };
            max = array[i];
            maxKey = i;

          }
          return maxKey;
        }

        function getAdjustment(first, center, last){
          const amplitudedConst=32;
          // const sampleRate = audioContext.sampleRate ;
          // const minFrequency = sampleRate  / 1024 / 2;
          // const maxFrequency = sampleRate / 2 - minFrequency;


///0: 191   8
// 1: 200
// 2: 181   19
          // const pitchPerChunk = (maxFrequency - minFrequency)/1025;

          const firstToCenter = center - first;
          const lastToCenter = center - last;
          const offset = firstToCenter - lastToCenter;
          // console.log(first, center, last, 1/offset/2);
   console.log(offset);

          return offset/amplitudedConst/2;



        }
        function maxKeyOffset(array, key) {
          let range = 1;
          if(key - range < 0){
            return 0;

          }
          if(key + range > 1024){
            return 0;
          }

          const ranges = [];
          for (var i = key - range; i <= key + range ; i++) {
            ranges.push(array[i -1]);
          }
           const first = ranges[0];
          const center = ranges[1];
          const last = ranges[2];



          return getAdjustment(first, center, last);
        }
        function updateVolumeMeter() {
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);
          // console.log(dataArray);
          const average = getAverageVolume(dataArray);
          let width = average * 2;
          volumeLevel.style.height = (width>100? 100 : width) + '%';
          storeAverageAmplitude(average,  Date.now() - startTime); 
          if(state === 'recording'){requestAnimationFrame(updateVolumeMeter)};
        }

        function updateLiveWave() {
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);

          canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

          function draw() {
            if(state === 'recording'){
              requestAnimationFrame(draw);
            }
            analyser.getByteTimeDomainData(dataArray);
            canvasCtx.fillStyle = 'rgb(200, 200, 200)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 0, 0)';

            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
              const v = dataArray[i] / 128.0;
              const y = v * canvas.height / 2;

              if (i === 0) {
                canvasCtx.moveTo(x, y);
              } else {
                canvasCtx.lineTo(x, y);
              }

              x += sliceWidth;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
          }

          draw();
        };

        function getAverageVolume(array) {
          let values = 0;
          const length = array.length;
          for (let i = 0; i < length; i++) {
            values += array[i];
          }
          return values / length;
        }

        function updateTimer() {
          const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsedTime / 60);
          const seconds = elapsedTime % 60;
          const milliseconds = Math.floor((Date.now() - startTime)/10 % 100);
          document.getElementById('timer').textContent = padNumber(minutes) + ':' + padNumber(seconds) + ':' + padNumber(milliseconds);
        }

        function padNumber(number) {
          return number.toString().padStart(2, '0');
        }

        document.getElementById('startButton').addEventListener('click', startRecording);
        document.getElementById('stopButton').addEventListener('click', stopRecording);

      })
      .catch(function(error) {
        console.error('Error accessing microphone:', error);
      });
  </script>
</body>
</html>
